#include <cassert>
#include <unordered_map>
#include <string>
#include <vector>

using namespace std::literals;

class Solution {
public:
    bool CheckPosition(int i, int j) {
        if (i == 1 || i == 4 || i == 7) {
            return (j == 1 || j == 4 || j == 7);
        }
        return false;
    }
    bool isValidSudoku(std::vector<std::vector<char>>& board) {
        for (int i = 0; i < 9; ++i) {
            std::unordered_map<char, int> row;
            std::unordered_map<char, int> collum;
            for (int j = 0; j < 9; ++j) {
                if (row.count(board[i][j]) || collum.count(board[j][i])) {
                    return false;
                }else {
                    if (board[i][j] != '.') {
                        ++row[board[i][j]];
                    }
                    if (board[j][i] != '.') {
                        ++collum[board[j][i]];
                    }
                }
                        // check square
            // for (int i = 0; i < 9; i += 3) {
            //     for (int j = 0; j < 9; j += 3) {
            if (CheckPosition(i, j)) {
                    std::unordered_map<char, int> square;
                    for (int n = -1; n < 2; ++n) {
                        for (int k = -1; k < 2; ++k) {
                            if (square.count(board[i + n][j + k])) {
                                return false;
                            }else {
                                if (board[i + n][j + k] != '.') {
                                    ++square[board[i + n][j + k]];
                                }
                            }
                        }
                    }
                }
                    // temp.clear();
            //     }
            // }
                
            }
        }
        // check square
        // for (int i = 0; i < 9; i += 3) {
        //     for (int j = 0; j < 9; j += 3) {
        //         std::unordered_map<char, int> square;
        //         for (int n = 0; n < 3; ++n) {
        //             for (int k = 0; k < 3; ++k) {
        //                 if (square.count(board[i + n][j + k])) {
        //                     return false;
        //                 }else {
        //                     if (board[i + n][j + k] != '.') {
        //                         ++square[board[i + n][j + k]];
        //                     }
        //                 }
        //             }
        //         }
        //         // temp.clear();
        //     }
        // }
        return true;
    }
};


int main () {
Solution s;
/*
{
    std::vector<std::vector<char>> v 
{{'.','.','.','9','.','.','.','.','.'}
,{'.','.','.','.','.','.','.','.','.'}
,{'.','.','3','.','.','.','.','.','1'}
,{'.','.','.','.','.','.','.','.','.'}
,{'1','.','.','.','.','.','3','.','.'}
,{'.','.','.','.','2','.','6','.','.'}
,{'.','9','.','.','.','.','.','7','.'}
,{'.','.','.','.','.','.','.','.','.'}
,{'8','.','.','8','.','.','.','.','.'}};
 assert(false == s.isValidSudoku(v));
}
{
    std::vector<std::vector<char>> v 
{{'.','.','.','9','.','.','.','.','1'}
,{'.','.','.','.','.','.','.','.','.'}
,{'.','.','3','.','.','.','.','.','1'}
,{'.','.','.','.','.','.','.','.','.'}
,{'1','.','.','.','.','.','3','.','.'}
,{'.','.','.','.','2','.','6','.','.'}
,{'.','9','.','.','.','.','.','7','.'}
,{'.','.','.','.','.','.','.','.','.'}
,{'8','.','.','8','.','.','.','.','.'}};
 assert(false == s.isValidSudoku(v));
}
 */
{
    std::vector<std::vector<char>> v 
{{'5','3','.','.','7','.','.','.','.'}
,{'6','.','.','1','9','5','.','.','.'}
,{'.','9','8','.','.','.','.','6','.'}
,{'8','.','.','.','6','.','.','.','3'}
,{'4','.','.','8','.','3','.','.','1'}
,{'7','.','.','.','2','.','.','.','6'}
,{'.','6','.','.','.','.','2','8','.'}
,{'.','.','.','4','1','9','.','.','5'}
,{'.','.','.','.','8','.','.','7','9'}};
 assert(true == s.isValidSudoku(v));
}
{
    std::vector<std::vector<char>> v 
{{'8','3','.','.','7','.','.','.','.'}
,{'6','.','.','1','9','5','.','.','.'}
,{'.','9','8','.','.','.','.','6','.'}
,{'8','.','.','.','6','.','.','.','3'}
,{'4','.','.','8','.','3','.','.','1'}
,{'7','.','.','.','2','.','.','.','6'}
,{'.','6','.','.','.','.','2','8','.'}
,{'.','.','.','4','1','9','.','.','5'}
,{'.','.','.','.','8','.','.','7','9'}};
 assert(false == s.isValidSudoku(v));
}
{
    std::vector<std::vector<char>> v 
{{'.','.','.','.','.','.','.','.','.'}
,{'.','.','.','.','.','.','.','.','.'}
,{'.','.','.','.','.','.','.','.','.'}
,{'.','.','.','.','.','.','.','.','.'}
,{'.','.','.','.','.','.','.','.','.'}
,{'.','.','.','.','.','.','.','.','.'}
,{'.','.','.','.','.','.','3','.','.'}
,{'.','.','.','.','.','.','.','.','.'}
,{'.','.','.','.','.','.','.','.','3'}};
 assert(false == s.isValidSudoku(v));
}
}