#include <cassert>
#include <unordered_map>
#include <unordered_set>
#include <string>
#include <vector>
#include <iostream>

using namespace std::literals;

class Solution {
public:

    std::vector<char> GetBox(std::vector<std::vector<char>>& board, int row, int colum) {
        int min_row = (row / 3) * 3;
        int min_colum = (colum / 3) * 3;
        std::vector<char> result;
        result.reserve(8);
        for (int i = min_row; i < min_row + 3; ++i) {
            for (int j = min_colum; j < min_colum + 3; ++j) {
                    result.push_back(board[i][j]);
            }
        }
        return result;
    }

    std::vector<char> InsertInt(std::vector<std::vector<char>>& board, int row, int colum) {
        std::unordered_set<char> available_number{'1','2','3','4','5','6','7','8','9'};
        std::vector<char> box_n = GetBox(board, row, colum);
        for (int i = 0; i < 9; ++i){
            if (board[row][i] != '.') {
                available_number.erase(board[row][i]);
            }
            if (board[i][colum] != '.') {
                available_number.erase(board[i][colum]);
            }
            if (box_n[i] != '.') {
                available_number.erase(box_n[i]);
            }
        }
        return {available_number.begin(), available_number.end()};

    }
    void solveSudoku(std::vector<std::vector<char>>& board) {
        // PrintBoard(board);
        while(true) {
            for (int row = 0; row < 9; ++row) {
                for (int colum = 0; colum < 9; ++colum) {
                    if (board[row][colum] == '.') {
                        auto temp = InsertInt(board, row, colum);
                        if (temp.size() == 1) {
                            //найдена ячейка для вставки
                            board[row][colum] = temp.back();
                            row = 0;
                            colum = 0;
                        }
                    }
                }
            }
        }
        
    }
};


int main () {
Solution s;
    std::vector<std::vector<char>> v
{{'5','3','.','.','7','.','.','.','.'}
,{'6','.','.','1','9','5','.','.','.'}
,{'.','9','8','.','.','.','.','6','.'}
,{'8','.','.','.','6','.','.','.','3'}
,{'4','.','.','8','.','3','.','.','1'}
,{'7','.','.','.','2','.','.','.','6'}
,{'.','6','.','.','.','.','2','8','.'}
,{'.','.','.','4','1','9','.','.','5'}
,{'.','.','.','.','8','.','.','7','9'}};
s.solveSudoku(v);
int i = 0;
/*
{
    std::vector<std::vector<char>> v 
{{'.','.','.','9','.','.','.','.','.'}
,{'.','.','.','.','.','.','.','.','.'}
,{'.','.','3','.','.','.','.','.','1'}
,{'.','.','.','.','.','.','.','.','.'}
,{'1','.','.','.','.','.','3','.','.'}
,{'.','.','.','.','2','.','6','.','.'}
,{'.','9','.','.','.','.','.','7','.'}
,{'.','.','.','.','.','.','.','.','.'}
,{'8','.','.','8','.','.','.','.','.'}};
 assert(false == s.isValidSudoku(v));
}
{
    std::vector<std::vector<char>> v 
{{'.','.','.','9','.','.','.','.','1'}
,{'.','.','.','.','.','.','.','.','.'}
,{'.','.','3','.','.','.','.','.','1'}
,{'.','.','.','.','.','.','.','.','.'}
,{'1','.','.','.','.','.','3','.','.'}
,{'.','.','.','.','2','.','6','.','.'}
,{'.','9','.','.','.','.','.','7','.'}
,{'.','.','.','.','.','.','.','.','.'}
,{'8','.','.','8','.','.','.','.','.'}};
 assert(false == s.isValidSudoku(v));
}
 */
// {
//     std::vector<std::vector<char>> v 
// {{'5','3','.','.','7','.','.','.','.'}
// ,{'6','.','.','1','9','5','.','.','.'}
// ,{'.','9','8','.','.','.','.','6','.'}
// ,{'8','.','.','.','6','.','.','.','3'}
// ,{'4','.','.','8','.','3','.','.','1'}
// ,{'7','.','.','.','2','.','.','.','6'}
// ,{'.','6','.','.','.','.','2','8','.'}
// ,{'.','.','.','4','1','9','.','.','5'}
// ,{'.','.','.','.','8','.','.','7','9'}};
//  assert(true == s.isValidSudoku(v));
// }
// {
//     std::vector<std::vector<char>> v 
// {{'8','3','.','.','7','.','.','.','.'}
// ,{'6','.','.','1','9','5','.','.','.'}
// ,{'.','9','8','.','.','.','.','6','.'}
// ,{'8','.','.','.','6','.','.','.','3'}
// ,{'4','.','.','8','.','3','.','.','1'}
// ,{'7','.','.','.','2','.','.','.','6'}
// ,{'.','6','.','.','.','.','2','8','.'}
// ,{'.','.','.','4','1','9','.','.','5'}
// ,{'.','.','.','.','8','.','.','7','9'}};
//  assert(false == s.isValidSudoku(v));
// }
// {
//     std::vector<std::vector<char>> v 
// {{'.','.','.','.','.','.','.','.','.'}
// ,{'.','.','.','.','.','.','.','.','.'}
// ,{'.','.','.','.','.','.','.','.','.'}
// ,{'.','.','.','.','.','.','.','.','.'}
// ,{'.','.','.','.','.','.','.','.','.'}
// ,{'.','.','.','.','.','.','.','.','.'}
// ,{'.','.','.','.','.','.','3','.','.'}
// ,{'.','.','.','.','.','.','.','.','.'}
// ,{'.','.','.','.','.','.','.','.','3'}};
//  assert(false == s.isValidSudoku(v));
// }
}